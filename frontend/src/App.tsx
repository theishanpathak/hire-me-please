import { useState } from "react"


interface MatchResult {
  score: number;
  matchDetails: string;
  missingKeywords: string[];
}

interface ChunkData {
  sectionName: string;
  chunk: string;
  startLine: number;
}

interface JDAnalysisResult {
  documentId: string;
  totalChunks: number;
  chunkData: ChunkData[];
}


function App() {
  //STATE: separate state for  inputs
  const [resumeFile, setResumeFile] = useState<File | null>(null);
  const [jdText, setJdText] = useState<string>('');


  //STATE: tracking ids generated by the backend
  const [resumeId, setResumeId] = useState<string>('');
  const [jdId, setJdId] = useState<string>('');

  //for status tracking and analysis ready display
  const [status, setStatus] = useState<string>('');
  const [analysis, setAnalysis] = useState<JDAnalysisResult | null>(null);
  const [matchResult, setMatchResult] = useState<MatchResult | null>(null);


  //Handler: handles both resume and JD submissions based on Type
  const handleJDUpload = async () => {
    if (!jdText.trim()) {
      setStatus("Error: Job Description text cannot be empty.");
      setJdId('');
      return;
    }

    setStatus(`Processing Job Description...`);
    setJdId('');

    try {
      const response = await fetch(`http://localhost:8080/api/document/jd`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ documentText: jdText })
      });

      if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Server responded with status ${response.status}`);
    }

      const result = await response.json();
      setJdId(result.documentId);
      setStatus("Succes: " + result.message);
    } catch (error) {
      setStatus('JD error: ' + error);
    }
  }

  //handles resume file upload
  const handleResumeUpload = async () => {
    if (!resumeFile) {
      setStatus("Please Select a file first")
      return;
    }

    setStatus("Uploading Resume...")

    const formData = new FormData();
    formData.append("file", resumeFile);


    try {
      const response = await fetch(`http://localhost:8080/api/document/resume`, {
        method: 'POST',
        //browser will automatically set the body as multipart/form-data
        body: formData
      });

      const result = await response.json();
      setResumeId(result.documentId);
      setStatus("Resume processed: " + result.message);
    } catch (error) {
      setStatus('Resume Error: ' + error)
    }
  }


  //handle match
  const handleMatch = async () => {
    setStatus("Running Matching Algorithm....");
    try {
      const response = await fetch(`http://localhost:8080/api/document/match?resumeId=${resumeId}&jdid=${jdId}`, {
        method: 'POST'
      });
      const result = await response.json();
      setMatchResult(result);
      setStatus("Match Analysis Complete!");
    } catch (error) {
      setStatus("Match Error: " + error);
    }
  }


  //fetch analysis
  const fetchAnalysis = async (id: string) => {
    if (!id) return;

    try {
      const res = await fetch(`http://localhost:8080/api/document/${id}`);
      if (!res.ok) throw new Error("Failed to fetch analysis");

      const result: JDAnalysisResult = await res.json();
      setAnalysis(result);
    } catch (error) {
      setStatus('Error fetching analysis: ' + error);
    }

  }




  return (
    <div className='app-container'>
      <h1>Hire Me Please - Document Ingestion</h1>

      {/* Upload Sections Wrapper */}
      <div className="upload-grid">
        <section className="card">
          <h3>Step 1: Upload Resume (PDF)</h3>
          <input
            type="file"
            accept=".pdf"
            className="file-input"
            onChange={(e) => setResumeFile(e.target.files ? e.target.files[0] : null)}
          />
          <button className="btn-secondary" onClick={handleResumeUpload}>Process Resume</button>
          {resumeId && <p className="success-text">✅ Resume ID: {resumeId}</p>}
        </section>

        <section className="card">
          <h3>Step 2: Upload Job Description</h3>
          <textarea
            className="text-area"
            rows={8}
            placeholder="Paste Job Description text here..."
            required
            value={jdText}
            onChange={(e) => setJdText(e.target.value)}
          />
          <button className="btn-secondary" onClick={handleJDUpload}>Process JD</button>
          {jdId && <p className="success-text">✅ JD ID: {jdId}</p>}
        </section>
      </div>

      <section className="match-section card">
        <h3>3. Comparison</h3>
        <p>Once both documents are processed, run the analysis.</p>
        <button
          className="btn-primary"
          onClick={handleMatch}
          disabled={!resumeId || !jdId}
        >
          Run Match Analysis
        </button>
      </section>

      {matchResult && (
        <div className="match-card">
          <h2>Match Results</h2>
          <div className="score-badge">Score: {matchResult.score}%</div>
          <p className="feedback-text"><strong>Feedback:</strong> {matchResult.matchDetails}</p>
          {matchResult.missingKeywords && (
            <div className="keywords-box">
              <strong>Missing Keywords:</strong>
              <ul>
                {matchResult.missingKeywords.map((kw, i) => <li key={i}>{kw}</li>)}
              </ul>
            </div>
          )}
        </div>
      )}

      {status && (
        <div className="status-container">
          <div className="status-message">
            <strong>Status:</strong> {status}
          </div>
          <div className="test-actions">
            {resumeId && (
              <button className="btn-test" onClick={() => fetchAnalysis(resumeId)}>Test Resume Analysis</button>
            )}
            {jdId && (
              <button className="btn-test" onClick={() => fetchAnalysis(jdId)}>Test JD Analysis</button>
            )}
          </div>
        </div>
      )}

      {analysis && (
        <div className="analysis-container">
          <hr className="divider" />
          <h2>Analysis Results for: {analysis.documentId}</h2>
          <p><strong>Total Chunks:</strong> {analysis.totalChunks}</p>

          <div className="chunk-list">
            {analysis.chunkData.map((item, index) => (
              <div key={index} className="chunk-item">
                <span className="chunk-meta">
                  [{item.sectionName}, Line {item.startLine}]:
                </span>
                <p className="chunk-text">"{item.chunk}"</p>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}

export default App